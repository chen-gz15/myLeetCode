1.两数相加  
    位运算，用&计算出进位，左移一位，用^提取出此刻合为1的位，加上进位即可（循环或递归）   
2.两数之和  
    输入两个保存每一位的链表，计算两个数的和并存在链表中输出。我采取了很蠢的方法就是一位一位加，然后判断是否为空，再把剩余的部分放上。实际上加法只需要判断if(carry||l1||l2)，即进位非空或者链表非空时，都需要执行加法。对应链表空则加0，然后%10算出本位存起来，/10算出carry下一次运算，循环完毕即可。     
3.最大非重复子串  
    输入一个字符串，判断其中连续的最长非重复子串的长度。其实就是从头遍历一遍，碰到重复的字符就把start移到上一个出现的该字符后面就好。问题在于如何迅速判断该字符是否出现过。我用的暴力循环感觉很蠢。。最好的方法是利用map。用字符做索引，存整数值，即map<char,int>，存的值就是i,一旦发现i比start大，就证明在这个start之后该字符出现过，令start等于存的i即可。判断max与i-start哪个大，最后输出即可。利用map来索引和直接存i，利用i和start的大小关系判断很大的降低了时间复杂度。  
4.求两有序数组的中位数  
    输入两个有序数组，用O(log(m+n))的复杂度，求其中位数。看到对数复杂度，应该使用二分法+递归进行的。可以写一个寻找第k个数的函数，分别看AB两个数组的第k/2个数，相当于让前面刚好有k个数，如果A=B，那么证明刚好是第k个数，随便返回一个就好。如果A<B，证明A的前k/2个数肯定不可能是总的第k个数，把A的前k/2个数去掉，继续找。如果A不够k/2，那么把A全算上，让B多几个即可。利用寻找第k个数，令两数组的标号和为k即可。    
5.最长子回文串    
    输入一个字符串，求其最小子回文串。回文串可以从中心向外扩展搜索，标记好起始位和终止位即可。我一开始搜索的时候分了奇偶两种情况，很麻烦。其实只需要把所有重复的字符都跳过即可，因为重复相连的字符一定可以构成回文串。之后理由substr函数提取出子串即可（我用assign感觉很蠢。。而且标记两头，为啥想不开要标记中间和长度呢2333333）
771.宝石与石头   
    输入两个字符串，一个为代表宝石的字符串，一个为代表石头的字符串，求石头里有多少个宝石。首先利用set()去除宝石中重复的元素，再直接遍历即可   
804.不同的莫尔斯电码   
    给定字母与莫尔斯电码的对应表，输入一个字符串list，输出其中字符串可以对应处多少不同的摩尔斯电码。可以利用set，将每个莫尔斯电码算出来后加入到set中，求set长度即可。
