1.两数相加  

    位运算，用&计算出进位，左移一位，用^提取出此刻合为1的位，加上进位即可（循环或递归）  
    
2.两数之和  

    输入两个保存每一位的链表，计算两个数的和并存在链表中输出。我采取了很蠢的方法就是一位一位加，然后判断是否为空，再把剩余的部分放上。实际上加法只需要判断if(carry||l1||l2)，即进位非空或者链表非空时，都需要执行加法。对应链表空则加0，然后%10算出本位存起来，/10算出carry下一次运算，循环完毕即可。  
    
3.最大非重复子串  

    输入一个字符串，判断其中连续的最长非重复子串的长度。其实就是从头遍历一遍，碰到重复的字符就把start移到上一个出现的该字符后面就好。问题在于如何迅速判断该字符是否出现过。我用的暴力循环感觉很蠢。。最好的方法是利用map。用字符做索引，存整数值，即map<char,int>，存的值就是i,一旦发现i比start大，就证明在这个start之后该字符出现过，令start等于存的i即可。判断max与i-start哪个大，最后输出即可。利用map来索引和直接存i，利用i和start的大小关系判断很大的降低了时间复杂度。  
    
